#!@PERL@
#  Copyright (C) 2012  Stanislav Sinyagin
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Stanislav Sinyagin <ssinyagin@yahoo.com>

BEGIN { require '@torrus_config_pl@'; }

use strict;
use warnings;
use Getopt::Long;

use JSON;
use XML::LibXML;
use IO::File;

use Torrus::Log;


$Torrus::Spectrum::nodes_path = 'nodes';

%Torrus::Spectrum::global_ddx_params =
    (
     'host-subtree'   => '/',
     'snmp-port'      => '161',
     'snmp-version'   => '2c',        
     'snmp-community' => 'public',
     'snmp-timeout'   => 3,
     'snmp-retries'   => 2,
     'CiscoIOS_cbQoS::classmaps-only' => 'yes',
     'RFC2863_IF_MIB::list-admindown-interfaces' => 'yes',
     'output-bundle'  => 'spectrum_nodes.xml',
     'data-dir'       => '@defrrddir@',
    );


$Torrus::Spectrum::node_selection_callback =
    sub {
        my $spec_node_data = shift;
        # return true if the node needs to be in DDX.
        # in this example, return only nodes which are part of a collection:
        #  return( defined($spec_node_data->{'__parents__'}{'0x62483a'}) );
        return 1; };


$Torrus::Spectrum::node_params_callback =
    sub {
        my $spec_node_data = shift;
        my $ddx_host_params = shift;
        # you can manipulate $ddx_host_params based on $spec_node_data
        return; };


my $infile;
my $outfile;
my $customisations_pl;
my @collections;
my $debug = 0;
my $verbose = 0;

my $ok = GetOptions( 'in=s'        => \$infile,
                     'out=s'       => \$outfile,
                     'cust=s'      => \$customisations_pl,
                     'verbose'     => \$verbose,
                     'debug'       => \$debug );

if( not $ok or not defined($infile) or not defined($outfile)
    or scalar( @ARGV ) > 0 )
{
    print STDERR "Usage: $0 --in=FILE --out=FILE [options...]\n",
    "Options:\n",
    " --in=FILE            Spectrum data generated by spectrumdevs\n",
    " --out=FILE           Output DDX file\n",
    " --cust=FILE.pl       Customisations Perl script\n",
    " --verbose            print extra information\n",
    " --debug              print debugging information\n";
    
    exit(1);
}

if( $debug )
{
    Torrus::Log::setLevel('debug');
}
elsif( $verbose )
{
    Torrus::Log::setLevel('verbose');
}

if( defined($customisations_pl) )
{
    if( not -r $customisations_pl )
    {
        Error('Customisations file is not readable: ' . $customisations_pl);
        exit(1);
    }

    eval {require $customisations_pl};
    if( $@ )
    {
        Error('Failed loading customisations file: ' . $@);
        exit(1);
    }
}
           

my $fh = new IO::File( $infile, 'r' );
if( not defined($fh) )
{
    Error('Cannot read ' . $infile . ': ' . $!);
    exit(1);
}

my $specdata;
{
    my $json = new JSON;
    local $/;
    my $json_data = <$fh>;
    $fh->close();        
    $specdata = eval { $json->decode( $json_data ) };
}
if( not defined($specdata) )
{
    Error('Error reading JSON contrent from ' . $infile . ': ' . $@);
    exit(1);
}


Verbose('Preparing to write ' . $outfile);

my $doc = XML::LibXML->createDocument( "1.0", "UTF-8" );
my $root = $doc->createElement('snmp-discovery');
$doc->setDocumentElement( $root );

{
    my $fileInfoNode = $doc->createElement('file-info');
    $root->appendChild( $fileInfoNode );
    
    my $formatNode = $doc->createElement('format-version');
    $formatNode->appendText('1.0');
    $fileInfoNode->appendChild( $formatNode );
}

{
    my $creatorNode = $doc->createElement('creator-info');
    $creatorNode->appendText
        ("This file is generated from Spectrum data\n" .
         "on " . scalar(localtime(time())));
    $root->appendChild( $creatorNode );
}


createParamsDom( \%Torrus::Spectrum::global_ddx_params, $doc, $root );

my $c_devices = 0;

foreach my $mh ( sort keys %{$specdata} )
{
    my $spec_node_data = $specdata->{$mh};
    
    if( not &{$Torrus::Spectrum::node_selection_callback}($spec_node_data) )
    {
        next;
    }

    my $name = $spec_node_data->{'MName'};
    my $params = {
        'system-id' => $name,
        'snmp-host' => $spec_node_data->{'Network_Address'},
        'snmp-port'      => $spec_node_data->{'Agent_Port'},
        'snmp-community' => $spec_node_data->{'Community_Name'},
        'output-file' => $Torrus::Spectrum::nodes_path . '/' . $name . '.xml',
        'SpectrumDevices::device-mh' => $mh,
    };

    &{$Torrus::Spectrum::node_params_callback}($spec_node_data, $params);

    my $hostNode = $doc->createElement('host');
    $root->appendChild( $hostNode );
    
    createParamsDom( $params, $doc, $hostNode );
    $c_devices++;
}

Verbose('Created DDX information for ' . $c_devices . ' devices');

if( $doc->toFile( $outfile, 2 ) )
{
    Info("Wrote $outfile");
}
else
{
    Error("Cannot write $outfile: $!");
    exit(1);
}

exit(0);






sub createParamsDom
{
    my $params = shift;
    my $doc = shift;
    my $parentNode = shift;

    foreach my $param ( sort keys %{$params} )
    {
        my $value = $params->{$param};
        if( defined($value) and $value ne '' )
        {
            my $paramNode = $doc->createElement('param');
            $paramNode->setAttribute( 'name', $param );
            $paramNode->setAttribute( 'value', $params->{$param} );
            $parentNode->appendChild( $paramNode );
        }            
    }
    
    return;
}


# Local Variables:
# mode: perl
# indent-tabs-mode: nil
# perl-indent-level: 4
# End:


